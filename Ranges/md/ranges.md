# Ranges

- There are three important components in ranges:
  - **Range**: A type that provides a begin iterator and end sentinel, so that it can be iterated over.
    - **`std::begin/end()`**, and semantically the complexity is amortized **`𝑂(1)`**.
    - A **`container`** is a range obviously.
  - **View**: A range that can be moved in 𝑂(1), copied in 𝑂(1) (or cannot be copied) and destructed in 𝑂(1) (do not consider the destruction of elements).
    - As its name “view”, it’s usually a type inspecting elements (like **`span`** that we’ve taught).
    - It’s also a kind of **`range`**, but usually it’s `non-owning` compared with **`containers`**.
  - **Range adaptor**:
    - A functor that can transform a **range/ranges** to a **`view`**. Since a **`view`** is also a **`range`**, it can transform a view to a view, and use a new adaptor to continue to transform.
    - You can connect a range with a range adaptor with **`operator|`**, which consists of a **pipeline**.

## Note

- Note1: According to iterators, range also has concepts like **`input/output/forward/bidirectional/random_access/contiguous_range`**.
- Note2: A significant feature of the view generated by range adaptor is that calculation happens **lazily**.
  - That is, the calculation will happen iff. you want to get the next value of new view.
  - For example, you want to get elements that are less than 5 in a vector.
    - If you test all elements first, and write them to a new vector, and you use the new vector to do something else, then it happens **eagerly**.
    - But range only provides a way to iterate, so when the user wants the first element that is less than 5, you can go through the vector and pause at the first element that satisfies it; when the user wants the next, you can continue to go through.
      - This just makes an illusion to the user that you have all satisfied elements.
